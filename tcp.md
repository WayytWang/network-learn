用go的http库能对`http://www.baidu.com`成功的发起请求

```GO
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

func main() {
	resp, err := http.Get("http://www.baidu.com")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	c, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	fmt.Println(string(c))
}

```

众所周知，HTTP是基于TCP的应用层协议。

应用层往下的协议是操作系统提供的。

http库调用了系统调用来使用操作系统提供的网络功能



tcp靠谱的协议

tcp的窗口控制

tcp的拥塞控制



tcp包头

- 端口
  - 源端口
  - 目标端口
- 序号
  - 序号
  - 确认序号
- 状态位
- 窗口大小





序号是为了解决顺序问题，机器A向机器B依次发送了两个包，分别是包1、包2，那么机器A一定是希望机器B知道包1应该是在包2前的。网络环境无法保证先发出去的包就一定会被对方先收到。所以包得有序号。

确认序号是为了解决对方是否收到我发出去的包的问题。机器A向机器B发送了包1，机器B收到后会回复一个包2。但是机器A只是单纯的收到包2，是不知道包2究竟是对包1的确认，还是机器2完全不知道包1的事情，是想有另外一件事想告诉机器A。

这个一会在抓包的分析时更加直观



为什么说TCP是靠谱的协议，机器A在一定时间内没收到机器B对包1的回复，机器A就会觉得对方没收到，它就会重新发包。

所以TCP的可靠不是它下层的IP层保证的，而是自己通过不断尝试去保证的。





为什么一定要建立连接？

机器A给机器B发送tcp包，那它们之间得建立一个连接。为什么非要建立连接呢？

tcp是可靠的协议，但是这个可靠是tcp这一层通过序号与确认序号自己做到的。那它们至少得初始化一个序号。 



三次握手



























1.tcp的三次握手与四次挥手





2.操作系统层面的事情

3.go语言发出请求