---
typora-root-url: pic 
---

写在前面的话

当程序员这么久，网络环节的内容往往是经不起细问的

环境准备

- 两台收发网络信号的电脑，我的是一台windows和一台mac，用来模拟不同主机之前的通信，虚拟机感觉不纯粹了

- 都能启动一个web服务，用于接收http请求，我用的是go语言的gin框架搭建的一个简单的web服务

- 都装好wireshark抓包

  学习网络一定得抓包

  ​									----- 鲁迅

篇1：网络基础

- 关于IP地址
  - CIDR与子网掩码

- 同一个网段内的网络通信
  - 网络分层概念以及网络数据包的层层包装
  - MAC地址与ARP协议抓包解析

- 不涉及到公网的跨网段网络通信(同一局域网内)
  - 跨网段消息时，发送链路与同网段通信有何不同

- 内网访问公网
  - 源端与目的端的内网IP地址重复时，网络层该如何处理

- 可能遇到的问题
  - 为什么IP地址与MAC地址都很重要？
  - 一系列不需要非常清楚但是又不能不知道的网络概念，如子网、vlan、局域网到底如何定义？、xx层交换机有什么区别

- 一台刚连上网的机器是怎么获得IP地址的

  - DHCP协议抓包解析

- DNS协议

  - DNS解析的完整过程

- TCP协议

  - 三次握手与四次挥手的抓包解析

  

提几个问题？

网卡是什么？

- 任何一台计算机想要连接网络，都需要网卡。现在的家用电脑都会有一张eth0网卡，用于连接以太网，以太网可以简单理解为有线连接的。还有一张wlan的网卡，用于连接无线网络。

二层交换机

- 作用于第二层，它会把发送者的数据包中的数据链路层的头取下来得到目标MAC地址，然后找到MAC地址对应的机器端口，将网络包转发。
- 

网桥、交换机、路由器、网关等等这些概念有什么区别



网段、子网、局域网、vlan？

为什么有了IP地址还需要MAC地址？

- MAC地址和IP地址都是唯一的，都能做到标识作用，那为什么还两个都需要
- todo：说明MAC地址格式和IP地址格式，IP地址具有定位功能但是可变，也就是说IP地址和网卡之间的关系可变，MAC地址没有定位功能，但是与网卡之间的关系是制造商绑死的。注：也有一些修改MAC地址的方法，但是那不是真正的修改，可以去搜索了解。
- 将IP地址、MAC地址做一个类比。IP地址像是我的住址，xx省xx市xx区xx街道xx小区xx栋xx号，有明显的定位功能，但是我可以搬家。MAC地址像是我的身份证号，没具体的定位功能（别杠说身份证号前几位可以表示省市，后面的还是无法定位），但是和我的关系是绑死的。
- 当只有MAC地址，没有IP地址时
  - 如果访问不同网段的服务，根本找不到。就好像拿着我的身份证号找我，我在附近还好，跨市跨省了几乎不可能找到。
- 当只有IP地址，没有MAC地址时
  - 当想要给指定机器A发送网络信息时，我知道了A的IP地址，但是后来A的IP地址被B使用了，这样我发送的包就到不了机器A上了。就好像其他人拿着我的住址找到我，但是我已经搬家了，他也不能确定找到的人到底是不是我，这时候如果能对一下身份证就好了。
- 所有IP地址和MAC地址都不能缺少。

- https://www.zhihu.com/question/21546408/answer/2591082762



网关和路由器有什么关系？









## 关于IP地址

在描述网络通信中用到的网络协议前，先聊聊IP地址。

在公司的时候，自己的IP地址经常和隔壁工位同事的IP地址非常像，比如我的是192.168.1.17，他是192.168.1.20。是因为我们是同一个网络号下的不同主机号，那么IP地址实际上由两部分组成：192.168.1这个不变的表示网络号，17、20是各自的主机号，组在一起就是同一网段的不同IP地址。

这种方式就是CIDR，无类型域间选路。无类型是相对于将IP地址区分成A、B、C、D、E五类的方式，但是由于分类方式已经不太适用于现在的网络使用情况了。一个完整的IP地址应该是：192.168.1.17/24，表示这个IP的前24位是网络号，后8位是主机号。

- 至于为什么是24位，是因为计算机都用2进制表示IP地址，每个*.*隔开的部分是8位2进制数，换成10进制就是在[0,255]区间内。
- 192.168.1.17的二进制表示就是：11000000 10101000 00000001 00010001

每一个网络号都有自己的*广播地址*，一般是这个网络号的最后一个主机号，即：192.168.1.255。如果向这个地址发送网络消息，该网络号下的所有机器都可以收到。

那么计算机是如何计算IP地址的网络号呢？

这就需要*子网掩码*。192.168.1.17/24相对应的子网掩码是255.255.255.0，转换成二进制，就是前24位都是1，后8位是0。如果将192.168.1.17和255.255.255.0做AND运算。1AND0 = 0、1AND1=1、0AND1=0，0AND0=0：

- （11000000 10101000 00000001 00010001）AND （11111111 11111111 11111111 00000000）= 11000000 10101000 00000001 00000000
- 11000000 10101000 00000001 00000000 转10进制 192.168.1.0

网络号就计算出来了。

好像看着转换二进制有点多余，我看的子网掩码有3个255，直接用*.*切割IP地址，取前面3段不就行了。

192.168.1.17/24这个IP地址对应的网络号下最多只能有255台机器，可是有时候255台根本不够用。这时候会想着要不把网络号缩短点，但是网络号的长度可能不是8的倍数，那么“切割”的方式就行不通。比如16.158.165.91/22，这时候就只能使用二进制了：

- 子网掩码的前22位都是1，11111111 11111111 11111100 00000000，转十进制：255.255.252.0
- 16.158.165.91的二进制表达是：00010000 10011110 10100101 01011011
- （00010000 10011110 10100101 01011011）AND (11111111 11111111 11111100 00000000) = 00010000 10011110 10100100 00000000
- 00010000 10011110 10100100 00000000转10进制 16.158.164.0，从结果来看，明显就不能采用“切割”的方式了。
- 那个网络号下的广播地址就是最后一个主机号，即00010000 10011110 10100111 11111111，16.158.167.255



TODO：公网和私网区别



## 同一个网络号内的通信

在192.168.31.46的机器上部署了一个web服务器（gin），通过192.168.31.144的机器使用Apifox对其发起HTTP请求。

首先同一个网络号的主机，可以认为都是可直接连上的

![](/同网段机器连接1.png)

当然不可能都这么连，一堆线乱七八糟，通常会用一个交换机：

![](/同网段机器连接2.png)

这样每台机器都只去连接交换机就能实现互连的方式简洁很多。

- 这一个很小的局域网。todo：说明局域网不等于一个网段

- 经常讲网络是分层的，机器之间怎么连起来的就是物理层，我们更关心物理层之上的网络协议。

这个请求非常简单，发送GET请求，param只有一个name：wang，服务端将wang返回给客户端。

但客户端要从发出网络数据包到服务端，“wang”需要层层包装的

![网络数据包构建过程](/网络数据包构建过程.png)

首先，在应用层，http的正文包会被加上HTTP头

- todo：简要介绍下http头内容

然后应用层将HTTP报文交给传输层，传输层使用的是TCP协议，传输层又给HTTP包加上一个TCP头

- todo：简要介绍下http头内容

传输层会把TCP报文交给网络层，网络层又给TCP包加上IP头

- todo：双方的IP地址。

然后IP报文交给链路层，链路层给加上MAC头，双方的MAC地址。

- todo：双方的MAC地址
- mac地址和ip地址有什么不同

物理层将整个数据包发送到服务端

服务端接受到数据包后，链路层会取出mac头，如果目标mac地址能和自己的mac地址对上，则会往上交给网络层，否则结束

网络层会取出ip头，如果目标ip地址和自己的ip地址能对上，则寻找目标端口对应的进程，则将数据表交给传输层

传输层取出tcp头，如果目标端口和自己进程的端口能对上，则交给应用层，也就是自己的web服务器了

web服务器根据http正文或者url中取出参数，执行业务逻辑，构建结果，再次使用http返回结果，这又是上面的过程。

对应的真实网络包

 ![](/http请求网络包.png)

- Hypertext Transfer Protocol
  - 应用层，HTTP协议
- Transmission Control Protocol
  - 传输层，使用的UDP协议
- Internet Protocol Version
  - 网络层
- Ethernet II
  - 链路层

总结：

- 网络协议是分层的，比如HTTP协议是应用层协议，TCP是传输层协议
- 网络包是层层加码的，高层的网络包会交到低层去包装，HTTP包（应用层）就会交到TCP（传输层）包装，没有哪个协议可以跳过层级

看着简单的过程，包含的网络协议其实非常多。我们从底层往上分析

### 链路层怎么知道目标的MAC地址？

在链路层，除了上层递下来的目标IP，是没有目标MAC地址的。这就涉及到：

- 如何 IP地址 ====> MAC地址

这里用到的是地址解析协议，即ARP（Address Resolution Protocol），是一个链路层协议

当网络包递给链路层后，链路层拿到了目标IP地址，首先会查看本地ARP表看是否能找到目标IP机器对应的MAC地址

 ![](/本地arp表.png)

但本地找不到时，会发起真正的ARP协议，我实验的过程中，为了能抓到对应的网络包，我把本地的ARP表删除之后再发起的HTTP请求

 前面说过MAC地址才是用来做小范围内（todo：更准确的描述）的定位，所以这个阶段并不知道该发给谁，没办法，只能广播。

 ![](/arp请求概要.png)

- 144是ARP请求，145是ARP应答

- 请求就是将“Who has 192.168.31.46？Tell 192.168.31.144”广播到网段内的所有机器，当然这里要带上自己的MAC地址，要不然别人怎么回答自己呢

   ![](/arp-req.png)

- 每台机器都会收到这个数据包，服务端这台机器一看，这好像是在问我呢，于是它就会回一封“信”，告诉客户端自己的MAC地址。

   ![](/arp-reply.png)

- 客户端收到这份信后，IP地址就成功的换到了MAC地址。这里还会缓存到ARP表，不必每次都去执行ARP协议获取。

### 网络层

在同一网段内的传输网络层的相对简单

### 传输层接到了应用层的包后，就直接能包装了吗？

众所周知，HTTP建立在TCP上，而TCP连接的建立需要三次握手，这个三次握手的时机在哪呢？

![](/建立tcp连接.png)

注：没

- 可以看到发出HTTP包之前，通过了三次握手
- 并且在HTTP之后，还一直发送Keep-Alive包维持这个连接
- TCP的细节在TCP的部分再进行抓包分析



## 不涉及到公网的跨网段网络通信(同一局域网内)

之前的网络情况是最简单的，机器都是直连的。

todo:重点介绍当链路层发现要发出去的包不是同一网段内时，会先去找网关

## 一台刚连上网的机器是怎么获得IP地址的

## DNS协议

## TCP协议



结束语

网络协议还有很多，应用层常见的还有P2P协议，基于HTTP的HTTPS，RPC协议。传输层还有UDP协议等。



以及我自己写这篇文章的目的--学习k8s中的容器网络。
