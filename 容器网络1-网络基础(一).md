# 前言

在学习kubernetes的过程中，比较头疼的一个问题就是容器网络。从宿主机与容器的通信、到同一宿主机上，容器与容器之间的通信、再到更复杂的跨宿主机的容器与容器的通信，都有其背后的实现原理。为了真正的了解容器网络的原理，我个人总结了入手的三个方面：

- 网络基础
- 容器原理
- 容器网络本身

容器网络说到底还是网络，所以网络基础是必要的。我在学习容器网络时，看到了`docker0网桥`，觉得熟悉又陌生，`网桥`这个词听到的太多了，但它到底干什么用的？
大部分网络方面的知识点给我的感觉都是这样，似乎都懂，但一细想就又挺懵的。这次索性好好整理下，重心是机器之间通信的基本逻辑，不会涉及到太多网络协议本身的解释。

熟悉了机器与机器之间的网络通信后，做好类比，就能很快的了解容器与容器间的网络通信。但在这之前，还需要弄清楚容器到底是怎么回事，于是我的第二部分会围绕Namespace、Cgroup和rootfs，再配合一些实操来描述容器的基本原理。

在熟悉完前两个部分后，容器网络本身倒是不需要多少篇幅就能写清楚。

# 网络基础

目的是了解机器与机器之间是如何网络通信的。这个问题可以拆分成两个部分：

- 首先需要知道它们之间通信的是个什么东西，当然是网络包，那这个网络包是什么样子的？
- 机器A想要给机器B发网络包，那机器A怎么知道机器B在哪呢？

第一个问题，网络包与网络分层有很强的对应关系，所以需要了解网络分层的原理，另外为了直观的看到网络包的样子，还需要借助抓包软件，本文使用的是`Wireshark`。

第二个问题，机器A能找到机器B的前提是，两台机器得是连着网的。网络中机器非常多的时候，肯定无法做到任意两台机器时间都是网线直连，而是会通过很多交换机。所以就需要知道众多机器是怎么连起来的。在此基础上，才能根据不同的连网情况分析出机器A是如何找到机器B的。



## 关于IP地址

在分析这两个问题之前，先聊聊IP地址。IP地址没有看起来的那么简单。

首先，连网成功的机器，一定会有一个IP地址。准确的说，IP地址不是机器的，是机器上面某一张网卡的。

在公司的时候，自己的IP地址经常和隔壁工位同事的IP地址非常像，比如我的是192.168.1.17，他是192.168.1.20。是因为我们的连网情况是属于同一个网段。

- 💡：`网段`，官方的概念：一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。
- 是不是看了和没看一样？好多网络概念的官方解释都如此。我建议学习网络不要在概念定义上钻牛角尖，重点是能理解网络世界运行的基本原理。
- 网段用个人的话来说，就是仅用二层交换机可达的机器组成的一个网络。二层交换机是什么？后面会有解释。

那么IP地址实际上可以拆成两部分：192.168.1这个不变的表示是哪个网段，17、20是各自的主机号，组在一起就是同一网段的不同IP地址。

这种方式就是`CIDR，无类型域间选路`。无类型是相对于将IP地址区分成A、B、C、D、E五类的方式，由于分类方式已经不太适用于现在的网络使用情况了，现在无类型才是主流。

一个完整的无类型IP地址应该是：192.168.1.17/24，表示这个IP的前24位是网络号（网段），后8位是主机号。

- 计算机用二进制表示IP地址，每个*.*隔开的部分是8位二进制数，总共是32位，每一段换成十进制就是在[0,255]区间内。
- 192.168.1.17的二进制表示就是：11000000.10101000.00000001.00010001

每一个网段还有自己的*网关地址*，一般是这个网络号的第一个主机号，即：192.168.1.1。这主要用于网段与网段之间的通信，后面会详细描述。

每一个网段都有自己的*广播地址*，一般是这个网络号的最后一个主机号，即：192.168.1.255。如果向这个地址发送网络包，该网段内的所有机器都可以收到。

那么操作系统是如何根据IP地址，计算其所属的网段呢？

这就需要*子网掩码*。以192.168.1.17/24为例，它相对应的子网掩码是255.255.255.0（前24位都是1，后8位是0）。如果将192.168.1.17和255.255.255.0做AND运算。

- 1 AND 0 = 0、1 AND 1 = 1、0 AND 1 = 0、0 AND 0 = 0
- （11000000 10101000 00000001 00010001）AND （11111111 11111111 11111111 00000000）= 11000000 10101000 00000001 00000000
- 前24位分别与1做AND运算，都保住了本来的值。后8位分别与1做AND运算，原本值都丢掉了。
- 11000000 10101000 00000001 00000000 转10进制 192.168.1.0

网络号就计算出来了。

子网掩码为1的位数，可以不是8的整数倍。比如16.158.165.91/22。子网掩码的前22位都是1，11111111 11111111 11111100 00000000，转十进制：255.255.252.0

- 16.158.165.91的二进制表达是：00010000 10011110 10100101 01011011
- （00010000 10011110 10100101 01011011）AND (11111111 11111111 11111100 00000000) = 00010000 10011110 10100100 00000000
- 00010000 10011110 10100100 00000000转十进制 16.158.164.0。
- 该网段的网关地址是网络号下的第一台主机号地址，即16.158.164.1。
- 该网段的广播地址就是网络号下的最后一个主机号，即00010000 10011110 10100111 11111111，16.158.167.255



## 网络包

聊完IP地址之后，该回到最初的问题了，即机器之间通信，是在通信什么东西？答案是：网络包。网络包和网络分层的关系非常密切，所以从分层开始聊起。

### 网络分层

分层对于工程化的好处就不再赘述了。那些四层模型、七层模型，也不从概念上去探索。当我们提到网络分层时，基本就是指如下分层：

- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层

接下来就通过一个例子，来讲讲各个层对网络包都干了些什么事情。

首先我在一台公网服务器上启动了一个用gin框架写的web服务，代码很简单:

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	router := gin.Default()

	//注册接口
	router.GET("/hello/get", GetHandler)
	//监听端口
	http.ListenAndServe(":8080", router)
}

func GetHandler(c *gin.Context) {
	value, exist := c.GetQuery("name")
	if !exist {
		value = "the name is not exist!"
	}
	c.JSON(http.StatusOK, value)
	return
}
```



#### 应用层

程序员写代码一般都是直接使用**应用层**。比如现在使用go语言，对"/hello/get"发起HTTP Get请求。
```go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
)

func main() {
	resp, err := http.Get("http://xxx.xxx.xxx.xxx:8080/hello/get?name=wang")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	c, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return
	}

	fmt.Println(string(c))
}
```

- `resp, err := http.Get("http://xxx.xxx.xxx.xxx:8080/hello/get?name=wang")`这行代码的期望的结果是发起请求后，得到服务器的响应。这个请求是发送 + 接收的过程，也就是"请求-响应模式"。
- 这一次http请求是运行这段代码的机器A与部署了百度服务端的机器B之间的通信，更微观的来看是代码跑起来之后的进程a，与百度服务端的进程b之间的通信。

但是应用层光靠自己做不到"请求-响应模式"。以HTTP协议为例，简单的来说，它需要做的事情，是在客户端和服务端之间，做一个约定，用于互相之间解析数据。上诉代码没有其他参数，举个例子：

- 比如现在使用浏览器，在京东查询自己的订单记录。浏览器（实际上前端代码）按照HTTP协议约定，将几个重要参数，如：用户id、希望查询订单的时间范围等，包装成了HTTP包。京东服务收到这个包后，解析出重要参数，查询出订单记录，然后把从数据库查到的订单信息，按照HTTP协议约定，返回给浏览器，展示给我们看。

#### 传输层

应用层干不了的事情，它交给了下一层，也就是**传输层**，传输层对应用层做出的承诺，就是帮应用层把网络包发给目的地去。至于能不能确保对方收到了，和把对方的回信交到应用层手里，这还得看具体采用的哪种传输层协议。

- 关于"请求-响应模式"，做个补充说明。
- 机器A给机器B发消息，然后机器B又给机器A发消息，这不一定是"请求-响应模式"。
- 响应是针对请求的回复，对于机器A来说，发出去的请求，得到了相关的响应，这才算成功。机器A给B发了一条消息，半小时后，机器B给A发了一条毫无关系的消息，这就不是"请求-响应模式"。
- 做到"请求-响应模式"，需要在A和B两台机器之间，建立一个稳定的连接。当B收到A的请求，并生成了响应的结果后，只有依赖这个稳定的连接，才能响应给A，要不然B也不知道结果该发给谁，即使知道发给A，A也不知道是对哪一条请求做的响应。
- 而能建立连接的传输层协议就是**TCP**协议，另外一种**UDP**就是面向无连接的。
- **TCP**是如何建立以及维护连接的，需要翻阅TCP的相关资料。

传输层也没真正干发送应用层给到的网络包的事情，TCP协议负责建立维护连接，如果了解这个过程，也就是三次握手、四次挥手这些，就能知道它也需要发送一些包。而传输层本身也没有做这个事情。而它是通过发送和接收一些网络包，建立状态机，形成了一个连接，至于具体是怎么发送的，它甩手给下一层了，也就是网络层。

#### 网络层

网络层在这里干的事情，是把传输层传递下来的包，加上网络层的头，头包括了自己的IP地址和目标的IP地址。这里看似乎网络层没干什么大事。而事实上，网络包在网络世界传输时，在交换机那一环节，它还要起大作用，具体见机器之间是怎么连网的章节。

#### 数据链路层

网络包真正发出去之前，数据链路层还要给网络包再加上一个头，包括了自己的MAC地址和目标机器的MAC地址。

##### MAC地址

MAC地址，全称 Media Access Address（媒体存取控制位址）。每一个网卡都有自己的MAC地址。和网卡的IP地址不同的是，网卡的MAC地址是唯一的，硬件制造商层面给它们锁死了，钥匙都给吞了。注：也有一些修改MAC地址的方法，但是那不是真正的修改，可以去搜索了解。

##### ARP协议

自己的MAC地址，操作系统很容易查到，但是目标机器的MAC地址怎么获取呢？这需要用ARP协议，即Address Resolution Protocol，地址解析协议。

这个协议是从数据链路层发起的，是一个二层的协议。它主要的做的事情是，向同一个网段内的所有机器，广播一个网络包，通过抓包，发现内容如下：

- Sender MAC Address
- Sender IP Address
- Target MAC Address
- Target IP Address

对于发送方来说，Sender相关信息都有的，Target相关只有IP地址没有MAC地址，而想要把网络包准确的发送到一台指定机器，IP地址和MAC地址都是必要的，原因下一小点会解释。所以这里只能采取广播的方式。

同一网段内的机器都能收到该网络包，当然也包括目标机器。

- 注：目标机器可能不在同一网段内，这个在机器之间是怎么连网章节再说明

目标机器收到网络包，它发现Target IP Address是自己，于是会对这个网络包做响应，响应内容自然就包括自己的MAC地址，这样发送方就拿到了目标机器的MAC地址。

##### 为什么有了IP地址还需要MAC地址？

- 既然MAC地址是唯一的，IP地址在同一个网段内也是唯一的，且都能做到标识作用，那为什么即使在同一个网段内通信也是两个地址都需要，更别说跨网段通信了。
- 同一个网段内的网卡的IP地址，是非常像的，所以IP地址具有定位功能，但它不是固定的，也就是说IP地址和网卡之间的关系可变。
- 而MAC地址没有定位功能，但是与网卡之间的关系是制造商绑死的。
- 将IP地址、MAC地址做一个类比。IP地址像是我的住址，xx省xx市xx区xx街道xx小区xx栋xx号，有明显的定位功能，但是我可以搬家。MAC地址像是我的身份证号，没具体的定位功能，但是和我的关系是绑死的。
- 当只有MAC地址，没有IP地址时
  - 如果访问不同网段的服务，根本找不到。就好像拿着我的身份证号找我，我在附近还好，跨市跨省了几乎不可能找到。
- 当只有IP地址，没有MAC地址时
  - 当想要给指定机器A发送网络信息时，我知道了A的IP地址，但是后来A的IP地址被B使用了，这样我发送的包就到不了机器A上了。就好像其他人拿着我的住址找到我，但是我已经搬家了，他也不能确定找到的人到底是不是我，这时候如果能对一下身份证就好了。
- 所有IP地址和MAC地址都不能缺少。
- 推荐一个对MAC地址解释的比较形象的视频：https://www.zhihu.com/question/21546408/answer/2591082762

#### 物理层

这一层就不太需要关心了，它会将层层加码好的网络包，通过物理介质发送到目的地去。

### 接收方的逆行为

接收方收到网络包后，数据链路层先处理网络包，它取出MAC头，发现目标MAC地址是自己，确认是发给自己的。然后将网络包向上抛给网络层，网络层取出IP头，发现目标IP也是自己，也继续挖往上抛到传输层，传输层取下TCP头，它会把网络包转给对应端口的进程，这时，应用层就拿到数据了。

### 抓包解析

整个流程：

应用层发起请求

传输层准备建立tcp连接，开始发送用于握手的包，于是把构建好得tcp握手包给到网络层

网络层准备把握手得网络包，加上IP头后，交给数据链路层

数据链链层需要给握手网络包加上目标机器的mac地址，于是发起arp协议，获取到后，将包交给物理层

传输层经过三次握手建立连接后，开始把应用层的http包，加上TCP头，然后往下层层传递，层层处理，最终发送

数据链路层接收对方响应网络包后，做MAC头校验，通过后转给网络层

网络层做IP头校验，通过后转给传输层

传输层通过TCP头中获得目标端口，找到端口对应的进程，把网络包转给该进程

应用层拿到数据，请求完毕

所以最核心的网络包，最开始是ARP包，然后是TCP握手包，再是HTTP包







## 机器之间是怎么连网的

从一张图开始：

![](D:\note\note\wang\network-learn\pic\机器之间是怎么连接的.png)

从图中能看到三个虚线框表示了网段A、B、C。

每个网段内的机器都连着一台二层交换机。在IP地址的部分，对网段的解释时，提到了网段是仅通过二层交换机可达的机器组成的网络。

### 二层交换机的主要职责是什么？

机器1要发送一个网络包给机器2，从图中可以看得出机器1和机器2不是同一根网线连起来的。而是通过了交换机连接的。

机器1发送给机器2的网络包先到了交换机这，交换机会从网络包中取出数据链路层的头，数据链路层是第二层，所以这个交换机叫二层交换机。

交换机拿到了目标机器（机器2）的MAC地址，它发现自己的从左往右数第二个插口的网线另一端是连着机器2，于是把网络包原封不动的从这个插口传给机器2。

todo:STP协议

### 三层交换机的主要职责是什么？

机器1想要发送一个网络包给机器3，当机器1的数据链路层对网络层传下来的网络包做处理时，它发现目标机器的IP地址和自己不在同一个网段。所以它没办法拿到对方的MAC地址（ARP是一个二层协议，仅在同一个网段内可用）。这个网络包需要跨网段传输，所以它只能将目标MAC地址填写成网关的MAC地址，这个网关就由三层交换机充当。

- 网关的IP地址，一般都是这个网段的第一个IP，而从图中可以看到，这个三层交换机连接了好多个网段，那说明，这个交换机可以有好多个IP地址。

三层交换机的特点就是可以拿到网络包的第三层，即网络层的头。它知道了目标机器的网段后，就会发现，自己的第二个插口就是连着这个网段的，于是把网络包从这个转发出去。

图中的拓扑结构比较简单，真实的网络环境中，往往这个交换机并没有直接连上目标网段，但是它通过学习，会知道该走那个端口转发网络包最终能到目的网段，即使这个端口后面的连的是另一个三层交换机。



遗留的问题
