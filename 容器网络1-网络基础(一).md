# 前言

在学习kubernetes的过程中，比较头疼的一个问题就是容器网络。宿主机与容器的通信、同一宿主机上，容器与容器之间的通信、再到更复杂的跨宿主机的容器与容器的通信。为了真正的了解容器网络的原理，我个人总结了入手的三个方面：

- 网络基础
- 容器原理
- 容器网络本身

容器网络说到底还是网络，所以网络基础是必要的。我在学习容器网络时，看到了`docker0网桥`，觉得熟悉又陌生，熟悉的是`网桥`这个词听到的太多了，陌生的是它到底干什么用的？
大部分网络方面的知识点给我的感觉都是这样，似乎都懂，但又一细想就挺懵的。这次索性好好整理下，重心是机器之间是怎样通信的，不会涉及到太多应用层的网络协议。

熟悉了机器与机器之间的网络通信后，做好类比，就能很快的了解容器与容器间的网络通信。但在这之前，还需要弄清楚容器到底是怎么回事，于是我的第二部分就是容器原理，围绕Namespace、Cgroup和rootfs，再配合一些实操来描述容器的基本原理。

在熟悉完前两个部分后，容器网络本身倒是不需要多少篇幅就能写清楚。

# 网络基础

目的是了解机器与机器之间是如何网络通信的。这个问题可以拆分成两个部分：

- 首先需要知道它们之间通信的是个什么东西，当然是网络包，那这个网络包是什么样子的？
- 机器A想要给机器B发网络包，那机器A怎么知道机器B在哪呢？

第一个问题，网络包与网络分层有很强的对应关系，所以需要了解网络分层的原理，另外为了直观的看到网络包的样子，还需要借助抓包软件，本文使用的是`Wireshark`。

第二个问题，机器A能找到机器B的前提是，两台机器得是连着网的。网络中机器非常多的时候，肯定不能纯靠网线，所以就需要知道众多机器是怎么连起来的。在此基础上，才更根据不同情况分析出机器A是如何找到机器B的。



## 关于IP地址

在分析这两个问题之前，先聊聊IP地址。IP地址没有看起来的那么简单。

首先，连网成功的机器，一定会有一个IP地址。

在公司的时候，自己的IP地址经常和隔壁工位同事的IP地址非常像，比如我的是192.168.1.17，他是192.168.1.20。是因为我们的连网情况是属于同一个网段。那么IP地址实际上可以拆成两部分：192.168.1这个不变的表示是哪个网段，17、20是各自的主机号，组在一起就是同一网段的不同IP地址。

这种方式就是`CIDR，无类型域间选路`。无类型是相对于将IP地址区分成A、B、C、D、E五类的方式，由于分类方式已经不太适用于现在的网络使用情况了，现在无类型才是主流。一个完整的IP地址应该是：192.168.1.17/24，表示这个IP的前24位是网络号（网段），后8位是主机号。

- 计算机用二进制表示IP地址，每个*.*隔开的部分是8位二进制数，换成十进制就是在[0,255]区间内。
- 192.168.1.17的二进制表示就是：11000000.10101000.00000001.00010001

每一个网段还有自己的*网关地址*，一般是这个网络号的第一个主机号，即：192.168.1.1。这主要用于网段与网段之间的通信，后面会详细描述。

每一个网段都有自己的*广播地址*，一般是这个网络号的最后一个主机号，即：192.168.1.255。如果向这个地址发送网络包，该网段内的所有机器都可以收到。

那么操作系统是如何根据IP地址，计算其所属的网段呢？

这就需要*子网掩码*。以192.168.1.17/24为例，它相对应的子网掩码是255.255.255.0（前24位都是1，后8位是0）。如果将192.168.1.17和255.255.255.0做AND运算。

- 1 AND 0 = 0、1 AND 1 = 1、0 AND 1 = 0、0 AND 0 = 0

- （11000000 10101000 00000001 00010001）AND （11111111 11111111 11111111 00000000）= 11000000 10101000 00000001 00000000
- 11000000 10101000 00000001 00000000 转10进制 192.168.1.0

网络号就计算出来了。

好像看着用位运算好像有点多余，我看到子网掩码前3段都是255，直接用*.*切割IP地址，取前面3段不就行了。

但是子网掩码为1的位数，可以不是8的整数倍。比如16.158.165.91/22。这时候用切割的方式就做不到了，正确做法应该是：。

- 子网掩码的前22位都是1，11111111 11111111 11111100 00000000，转十进制：255.255.252.0
- 16.158.165.91的二进制表达是：00010000 10011110 10100101 01011011
- （00010000 10011110 10100101 01011011）AND (11111111 11111111 11111100 00000000) = 00010000 10011110 10100100 00000000
- 00010000 10011110 10100100 00000000转十进制 16.158.164.0。
- 该网段的网关地址是网络号下的第一台主机号地址，即16.158.164.1。
- 该网段的广播地址就是网络号下的最后一个主机号，即00010000 10011110 10100111 11111111，16.158.167.255



## 网络包

聊完IP地址之后，回到最初的问题了。

### 网络分层

分层对于工程化的好处就不再赘述了。当我们提到网络分层时，是指如下分层：

- 应用层
- 传输层
- 网络层
- 数据链路层
- 物理层

程序员写代码一般都是直接使用应用层。比如现在使用go语言，对"https://www.baidu.com"发起HTTP Get请求。
```go
func main() {
	resp, err := http.Get("https://www.baidu.com")
	if err != nil {
		panic(err)
	}
	fmt.Printf("resp:%+v", resp)
}
```

- `resp, err := http.Get("https://www.baidu.com")`这行代码的期望的结果是，对"https://www.baidu.com"发起请求后，并得到对方服务的响应结果。

但是应用层干不成"一发一收"这件事。以HTTP协议为例，简单的来说，它需要做的事情，是在客户端和服务端之间，做一个约定，用于互相之间解析数据。上诉代码没有其他参数，















比如现在使用浏览器，在京东查询自己的订单记录。

机器A访问部署了京东服务的机器B，更微观点看，是运行在机器A上的浏览器进程，访问了部署在机器B上的京东服务进程。

浏览器使用了HTTP协议发送请求，HTTP协议是一个应用层协议。在应用层，发送方一般只管按照协议约定构建数据，接收方只管按照协议约定解析数据。从这个例子来看，浏览器按照协议约定，将几个重要参数，如：用户id、希望查询订单的时间范围等，包装成了HTTP包。京东服务收到这个包后，解析出重要参数，查询出订单记录，然后给浏览器做出应答。一次HTTP请求包括了浏览器发起请求和京东服务做出应答。但请求-应答是对应着一来一回两个网络包。

应用层不仅管不了HTTP包是怎么到目的地的，而且还期望着能收到应答。它做不了的事情，就把包转给了下一层，也就是传输层。

传输层有两种协议：TCP协议和UDP协议。UDP协议面向无连接的，TCP协议是面向连接的。HTTP期望它的请求能有应答，所以使用TCP协议。

传输层现在有了HTTP包，它先要为浏览器进程与京东服务进程建立连接，进程的标识是端口号。建立连接的过程就是著名的三次握手。三次握手过程中也会发出一些网络包，但这些包和HTTP没什么关系，握手是TCP层面的事情。

建立连接后，传输层给HTTP包加上了TCP头，





## 机器之间是怎么连网的



































## 网络组成

## 通信过程

